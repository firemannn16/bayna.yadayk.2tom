<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Арабский тренажёр</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width:900px; margin:auto; }
    #intro { background: #fff; padding:16px; border-radius:8px; border:1px solid #ddd; margin-bottom:16px; }
    #dua { direction: rtl; font-size:2em; margin:12px 0; font-weight:600; }
    #arabicWord { font-size:2rem; direction: rtl; margin:12px 0; font-weight:600; text-align:right; }
    input[type="text"]{ width:100%; padding:8px; font-size:1rem; box-sizing:border-box; }
    button{ padding:8px 12px; margin-top:8px; }
    textarea { width:100%; box-sizing:border-box; padding:8px; font-size:0.95rem; resize:vertical; }
    #correct-list { min-height:60px; font-weight:700; background:#fffdf5; border:1px solid #e0d7c2; }
    #mistake-list { min-height:120px; font-weight:400; background:#f9f9f9; border:1px solid #ddd; }
    .btn-row { margin-top:8px; display:flex; gap:8px; flex-wrap:wrap; }
    #controls, #trainer { margin-top:16px; }
    .small { font-size:0.9rem; color:#444; margin-top:6px; }
    .hidden { display:none; }
    h3 { margin-bottom:6px; margin-top:16px; }

    /* modal */
    .overlay { position:fixed; left:0; top:0; right:0; bottom:0; background:rgba(0,0,0,0.4); display:flex; align-items:center; justify-content:center; z-index:1000; }
    .modal { background:white; padding:20px; border-radius:8px; max-width:500px; width:90%; box-shadow:0 6px 20px rgba(0,0,0,0.2); }
    .modal h2 { margin-top:0; }
    .modal .correct { direction: rtl; font-size:1.4em; font-weight:600; margin:10px 0; }
    .modal .controls { display:flex; gap:8px; justify-content:flex-end; margin-top:12px; }
  </style>
</head>
<body>
  <!-- Начальный экран с дуа -->
  <div id="intro">
    <h1>Перед началом тренировок</h1>
    <p>Дуа:</p>
    <div id="dua">رَّبِّ زِدْنِى عِلْمًۭا</div>
    <p>Перевод: «Господь мой! Приумножь мои знания»</p>
    <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
      <button id="doneDua" disabled>Я сделал дуа</button>
    </div>
  </div>

  <!-- Основной интерфейс -->
  <div id="main" class="hidden">
    <h1>Арабский тренажёр</h1>

    <div id="progress" class="small"></div>
    <div id="arabicWord"></div>

    <input id="userInput" type="text" placeholder="Введите перевод на русском">
    <br>
    <button id="submitBtn">Ответить</button>

    <h3>Правильно (можно растянуть рамку):</h3>
    <textarea id="correct-list" readonly placeholder="Здесь будут верные ответы..."></textarea>

    <h3>Ошибки (можно растянуть рамку):</h3>
    <textarea id="mistake-list" readonly placeholder="Здесь будут ваши ошибки..."></textarea>

    <div class="btn-row">
      <button id="copyCorrectsBtn">Копировать правильные</button>
      <button id="copyMistakesBtn">Копировать ошибки</button>
      <button id="clearMistakesBtn">Очистить ошибки</button>
      <button id="startMistakesBtn" class="hidden">Работа над ошибками</button>
      <!-- Перенёс сюда кнопку обновления словаря (сброс прогресса) -->
      <button id="refreshDictBtn">Обновить словарь (сбросить прогресс)</button>
    </div>
  </div>

  <!-- Modal placeholder -->
  <div id="modal-root"></div>

<script>
  // words.txt должен быть в корне репозитория
  let words = []; // { rawLine, ruVariants:[], arFull }
  let currentIndex = null;
  let mistakes = []; // строки rawLine
  let correctLines = [];
  let order = [];
  let mode = 'all'; // 'all' или 'mistakes'
  let modalTimeout = null;

  const STORAGE_KEY = 'arabicTrainerState_v1';

  // ----------------- Persistence (localStorage) -----------------
  function saveState() {
    try {
      const state = {
        ts: Date.now(),
        order, // remaining queue
        currentIndex,
        mistakes,
        correctLines,
        mode,
        wordsList: words.map(w => w.rawLine) // full list for merge
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch (e) { console.warn('saveState failed', e); }
  }

  function clearSavedState() { localStorage.removeItem(STORAGE_KEY); }

  // load + merge: restores saved state and appends new words if any
  function loadStateAndMerge() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      const s = JSON.parse(raw);
      if (!s || !Array.isArray(s.wordsList)) return false;

      const oldList = s.wordsList;
      const newList = words.map(w => w.rawLine);

      // exact match -> restore directly
      if (oldList.length === newList.length && oldList.every((v,i) => v === newList[i])) {
        order = Array.isArray(s.order) ? s.order.slice() : [];
        currentIndex = typeof s.currentIndex !== 'undefined' ? s.currentIndex : null;
        mistakes = Array.isArray(s.mistakes) ? s.mistakes.slice() : [];
        correctLines = Array.isArray(s.correctLines) ? s.correctLines.slice() : [];
        mode = s.mode || 'all';
        document.getElementById('mistake-list').value = mistakes.join('\n');
        document.getElementById('correct-list').value = correctLines.join('\n');
        return true;
      }

      // Merge/append logic: map rawLine -> new index
      const newIndexByRaw = new Map();
      newList.forEach((raw, idx) => newIndexByRaw.set(raw, idx));

      // keep only mistakes/corrects that still exist
      mistakes = (Array.isArray(s.mistakes) ? s.mistakes.slice() : []).filter(r => newIndexByRaw.has(r));
      correctLines = (Array.isArray(s.correctLines) ? s.correctLines.slice() : []).filter(r => newIndexByRaw.has(r));

      // build new order: map old order entries to new indices, then append any unseen new indices
      const seen = new Set();
      const newOrder = [];

      if (Array.isArray(s.order)) {
        for (const oldIdx of s.order) {
          const raw = oldList[oldIdx];
          if (!raw) continue;
          const newIdx = newIndexByRaw.get(raw);
          if (typeof newIdx === 'number' && !seen.has(newIdx)) {
            newOrder.push(newIdx);
            seen.add(newIdx);
          }
        }
      }

      for (let i = 0; i < newList.length; i++) {
        if (!seen.has(i)) { newOrder.push(i); seen.add(i); }
      }

      order = newOrder;

      // remap currentIndex by raw
      if (typeof s.currentIndex === 'number') {
        const curRaw = oldList[s.currentIndex];
        const mapped = newIndexByRaw.get(curRaw);
        currentIndex = (typeof mapped === 'number') ? mapped : null;
      } else {
        currentIndex = null;
      }

      mode = s.mode || 'all';
      document.getElementById('mistake-list').value = mistakes.join('\n');
      document.getElementById('correct-list').value = correctLines.join('\n');

      // persist merged state
      saveState();
      return true;
    } catch (e) { console.warn('loadStateAndMerge failed', e); return false; }
  }
  // ---------------------------------------------------------------

  // Detect reload navigation: if user pressed browser Refresh (F5), treat as force reload
  function isPageReload() {
    try {
      const nav = performance.getEntriesByType && performance.getEntriesByType('navigation') && performance.getEntriesByType('navigation')[0];
      if (nav && nav.type) return nav.type === 'reload';
      if (performance.navigation) return performance.navigation.type === 1; // older browsers
    } catch(e) {}
    return false;
  }

  async function loadWords() {
    try {
      const res = await fetch('words.txt');
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const txt = await res.text();
      const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
      words = lines.map(line => {
        const sepIndex = line.search(/[-–—]/);
        let ru = '', ar = '';
        if (sepIndex !== -1) {
          ru = line.slice(0, sepIndex).trim();
          ar = line.slice(sepIndex + 1).trim();
        } else { ru = line; ar = ''; }
        const ruVariants = ru.split(',').map(r => r.trim().toLowerCase()).filter(r => r);
        return { rawLine: line, ruVariants, arFull: ar };
      });
      document.getElementById('doneDua').disabled = false;

      // If user reloaded the page (pressed Refresh), discard saved state and start fresh
      if (isPageReload()) {
        clearSavedState();
        prepareOrder();
        document.getElementById('intro').classList.remove('hidden');
        document.getElementById('main').classList.add('hidden');
        return;
      }

      // otherwise try to restore+merge previous session
      const restored = loadStateAndMerge();
      if (!restored) {
        prepareOrder();
      } else {
        // restored/merged — open trainer immediately
        document.getElementById('intro').classList.add('hidden');
        document.getElementById('main').classList.remove('hidden');
        if (currentIndex !== null && typeof words[currentIndex] !== 'undefined') {
          displayCurrent();
        } else {
          nextWord();
        }
      }
    } catch (err) {
      document.getElementById('doneDua').disabled = false;
      document.getElementById('arabicWord').textContent = 'Не удалось загрузить words.txt: ' + err;
    }
  }

  function shuffleIndices(n) {
    const arr = [...Array(n).keys()];
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function prepareOrder(source = 'all') {
    if (source === 'all') {
      order = shuffleIndices(words.length);
      mode = 'all';
    } else if (source === 'mistakes') {
      const idxs = [];
      for (const raw of mistakes) {
        const found = words.findIndex(w => w.rawLine === raw);
        if (found !== -1) idxs.push(found);
      }
      order = idxs;
      mode = 'mistakes';
    }
    saveState(); // persist new order
  }

  function displayCurrent() {
    if (currentIndex !== null && typeof words[currentIndex] !== 'undefined') {
      const w = words[currentIndex];
      document.getElementById('arabicWord').textContent = w.arFull || w.rawLine;
      updateProgress();
      document.getElementById('userInput').value = '';
      document.getElementById('userInput').focus();
    } else {
      nextWord();
    }
  }

  function nextWord() {
    if (!order || order.length === 0) {
      if (mode === 'mistakes' && mistakes.length === 0) {
        document.getElementById('arabicWord').textContent = 'Ошибок нет.';
        return;
      }
      // prepare depending on mode
      prepareOrder(mode === 'mistakes' ? 'mistakes' : 'all');
    }
    if (order.length === 0) {
      document.getElementById('arabicWord').textContent = 'Нет слов для тренировки.';
      return;
    }
    const idx = order.shift();
    currentIndex = idx;
    const w = words[idx];
    document.getElementById('arabicWord').textContent = w.arFull || w.rawLine;
    updateProgress();
    document.getElementById('userInput').value = '';
    document.getElementById('userInput').focus();
    saveState();
  }

  function normalizeRu(s) {
    return s.trim().toLowerCase().replace(/ё/g, 'е');
  }

  function showWrongModal(correctText, afterCloseCallback) {
    closeModal();
    const root = document.getElementById('modal-root');
    const overlay = document.createElement('div'); overlay.className = 'overlay';
    const modal = document.createElement('div'); modal.className = 'modal';
    modal.innerHTML = `
      <h2>Неправильно</h2>
      <div>Правильный ответ:</div>
      <div class="correct">${escapeHtml(correctText)}</div>
      <div class="controls">
        <button id="modalClose">Закрыть (Esc)</button>
      </div>
    `;
    overlay.appendChild(modal);
    root.appendChild(overlay);

    function cleanup() {
      if (modalTimeout) { clearTimeout(modalTimeout); modalTimeout = null; }
      document.removeEventListener('keydown', onKey);
      if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
    }
    function onKey(e) { if (e.key === 'Escape') { cleanup(); if (typeof afterCloseCallback === 'function') afterCloseCallback(); } }
    document.getElementById('modalClose').addEventListener('click', () => { cleanup(); if (typeof afterCloseCallback === 'function') afterCloseCallback(); });
    document.addEventListener('keydown', onKey);
    modalTimeout = setTimeout(() => { cleanup(); if (typeof afterCloseCallback === 'function') afterCloseCallback(); }, 17000);
  }

  function closeModal() { const root = document.getElementById('modal-root'); root.innerHTML = ''; if (modalTimeout) { clearTimeout(modalTimeout); modalTimeout = null; } }

  function checkAnswer() {
    if (currentIndex === null) return;
    const inputRaw = document.getElementById('userInput').value;
    const input = normalizeRu(inputRaw);
    if (!input) return;
    const w = words[currentIndex];
    const ok = w.ruVariants.some(v => normalizeRu(v) === input || normalizeRu(v) === input.replace(/е/g,'ё'));
    if (ok) {
      correctLines.push(w.rawLine);
      document.getElementById('correct-list').value = correctLines.join('\n');
      currentIndex = null;
      saveState();
      if (order.length === 0) finishSession(); else nextWord();
    } else {
      mistakes.push(w.rawLine);
      document.getElementById('mistake-list').value = mistakes.join('\n');
      saveState();
      const correctText = w.rawLine;
      showWrongModal(correctText, () => { currentIndex = null; if (order.length === 0) finishSession(); else nextWord(); });
    }
  }

  function finishSession() {
    updateProgress();
    const btn = document.getElementById('startMistakesBtn');
    if (mistakes.length) btn.classList.remove('hidden');
    document.getElementById('arabicWord').textContent = `Готово! Пройдено ${ (mode==='all') ? words.length : mistakes.length }/${words.length} , ошибок: ${mistakes.length}`;
    currentIndex = null;
    saveState();
  }

  function updateProgress() {
    const done = words.length - order.length;
    document.getElementById('progress').textContent = `${done}/${words.length} слов пройдено – ${mistakes.length} ошибок`;
  }

  function copyTextToClipboard(text, msg) {
    if (!text) { alert('Нет данных для копирования.'); return; }
    navigator.clipboard.writeText(text).then(()=> alert(msg)).catch(()=> {
      const ta = document.createElement('textarea'); ta.value = text; document.body.appendChild(ta); ta.select();
      try { document.execCommand('copy'); alert(msg); } catch(e) { alert('Не удалось скопировать'); }
      ta.remove();
    });
  }

  function copyCorrects() { copyTextToClipboard(correctLines.join('\n'), 'Правильные ответы скопированы'); }
  function copyMistakes() { copyTextToClipboard(mistakes.join('\n'), 'Ошибки скопированы'); }

  function clearMistakes() {
    if (!confirm('Очистить список ошибок?')) return;
    mistakes = [];
    document.getElementById('mistake-list').value = '';
    document.getElementById('startMistakesBtn').classList.add('hidden');
    updateProgress();
    saveState();
  }

  document.getElementById('submitBtn').addEventListener('click', checkAnswer);
  document.getElementById('userInput').addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); checkAnswer(); }});
  document.getElementById('copyCorrectsBtn').addEventListener('click', copyCorrects);
  document.getElementById('copyMistakesBtn').addEventListener('click', copyMistakes);
  document.getElementById('clearMistakesBtn').addEventListener('click', clearMistakes);

  document.getElementById('startMistakesBtn').addEventListener('click', () => {
    if (!mistakes.length) return;
    prepareOrder('mistakes');
    correctLines = [];
    document.getElementById('correct-list').value = '';
    document.getElementById('mistake-list').value = mistakes.join('\n');
    document.getElementById('startMistakesBtn').classList.add('hidden');
    mode = 'mistakes';
    saveState();
    nextWord();
  });

  // manual "refresh dictionary" button: clear saved state and reload so new words.txt is used
  document.getElementById('refreshDictBtn').addEventListener('click', () => {
    if (!confirm('Сбросить текущую сессию и загрузить обновлённый словарь?\nЭто удалит текущее сохранение прогресса.')) return;
    clearSavedState();
    location.reload();
  });

  document.getElementById('doneDua').addEventListener('click', () => {
    document.getElementById('intro').classList.add('hidden');
    document.getElementById('main').classList.remove('hidden');
    if (words.length) nextWord();
  });

  // autosave before tab closes
  window.addEventListener('beforeunload', saveState);

  loadWords();

  function escapeHtml(s) { return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[c]); }
</script>
</body>
</html>
